%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper,12pt]{article}

\usepackage{amsmath} % Required for some math elements
\usepackage{comment}  % Required for multiline comments
\usepackage{geometry}
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to ABB
\usepackage[linesnumbered,ruled,vlined,algo2e]{algorithm2e} % Required for presenting algorithms
\usepackage{setspace} % This is used in the title page

\usepackage{times}

\newcommand{\newpar}{\smallskip\noindent} %command to create new paragraph with no ident.
\newcommand{\commenter}[3]{$[$\uppercase{#1}#2:#3$]$  \\}
\newcommand{\vitali}[2]{\commenter{vitali}{#1}{#2}}
\newcommand{\maor}[2]{\commenter{maor}{#1}{#2}}
%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------
\begin{document}

\newgeometry{top=2cm, bottom=2cm, right=2cm, left=2cm}

\begin{center}
{\large Ben-Gurion University of the Negev \\ Faculty of Engineering Science \\ Department of Information Systems Engineering} \\
\vspace*{2mm}
\begin{spacing}{1.5}
\textbf{Final Report} \\ 
{\LARGE \uppercase{OCCT: One-Class Clustering Tree \\ Implementation for Weka}}
\end{spacing}
\vspace*{2mm}
{\large \textbf{Vitali Sepetnitsky, Maor Tal}} \\
\vspace*{2mm}
\textbf{Instructor:} Dr. Asaf Shabtai \\
\vspace*{2mm}
\textbf{\date{\today}} % Date for the report
\end{center}
%----------------------------------------------------------------------------------------
%	SECTION 1 - Introduction
%----------------------------------------------------------------------------------------
\vspace*{-1.5cm}
\section{Introduction}
\begin{spacing}{1.5}
Data linkage is the task of identifying different entries (i.e., data items) that refer to the same
entity across different data sources \cite{damaging2011}, \cite{kamra2008detecting}. Record linkage refers to the task of joining datasets
that do not share a common identifier (i.e., a foreign key).

\subsection{OCCT}
The two common types of data linkage are:
\begin{itemize}
  \item \emph{one-to-one} data linkage in which the goal is to associate
an entity from one dataset with a single matching entity from the another dataset.
  \item \emph{one-to-many} where the goal is to associate an entity from the first
   dataset to a group of matching entities from the other dataset.
\end{itemize}
\newpar{OCCT} (One-Class Clustering Tree) is a novel data linkage method, presented in \cite{dror2011thesis} and \cite{dror2014occt},
which is capable of performing one-to-many data linkage between entities of same or different
types. The tree is built such that it is easy to transform it into association rules.

One of the major advantages of OCCT compared to other data linkage methods, is using the
one-class approach. This means that it needs only examples of matching pairs in order to learn
and build the model. This feature is important since in many domains it is difficult to obtain
nonmatching examples (e.g. the fraud detection domain).

Building the tree requires deciding which attribute should be selected at each level. There are
four different “splitting criteria” proposed by the authors in \cite{dror2014occt}, along with two pre-pruning process,
to stop expanding branches that does not improve the accuracy of the model.

Once the construction of the tree is completed, a set of probabilistic models are induced for each
of the leafs of the tree.
Each model is deriving the probability of a value of a given attribute from table ($T_{B}$) that
is most likely to be linked with a record from the first table ($T_{A}$).

\subsection{Weka}
Weka (Waikato Environment for Knowledge Analysis) is a suite of machine learning software
which contains a collection of algorithms and visualization tools for data analysis and machine
learning, along with graphical user interfaces for easy access to its functionality. Weka is
free software available under the GNU General Public License.
It is written in Java and developed at the University of Waikato, New Zealand. Weka is also well-suited
for developing new machine learning schemes.

%----------------------------------------------------------------------------------------
%	SECTION 2 - Motivation, Project Goals
%----------------------------------------------------------------------------------------
\section{Motivation}
OCCT was evaluated by the authors in \cite{dror2011thesis} and \cite{dror2014occt} as a part of a detection system framework
designed for detecting potential data leakage/misuse. The detection system was
designed to incorporate multiple detectors as plug-ins, where each detector implements a
different detection algorithm, such as OCCT.

The original implementation suffered from many drawbacks, especially it was designed for a
specific domain and did not use any common interfaces which are used in Weka. This made it impossible to
be used by other researchers in order to perform more extensive evaluation and research on OCCT.
In addition evaluating OCCT versus other data linkage algorithms which are already implemented within Weka
was a tedious task.

Our project goal is to implement OCCT, using Weka common API for machine learning
algorithms, and provide basic evaluation of OCCT using our implementation. We intend to add
OCCT as one of the classifiers in Weka UI and make it available to researchers who wishes to further
evaluate OCCT.

%----------------------------------------------------------------------------------------
%	SECTION 3 - Code Structure
%----------------------------------------------------------------------------------------
\section{Code Structure}
The code was carefully designed in order to be flexible for future extensions and also be as readable as possible. Its implementation is based on the J48, which is an open source Java implementation of the C4.5 algorithm in Weka.

\subsection{Packages}
The packages structure of the code can be seen in Figure \vitali{TODO}. This structure allows an easy merge process with the existing Weka source code. The parent packages are {\em src.main.java.weka} which is similar to Weka packages. Then, inside the {\em weka} package, there is {\em classifiers} package which contains different classifiers. Since our implementation was inspired from J48, we placed the main class in file {\em occt.java} inside {\em src.main.java.weka.trees.classifiers}. Other parts of the implementation are located inside {\em trees.occt} package.

The {\em occt} package was divided to three packages: {\em split}, {\em tree} and {\em utils}. The first package, {\em split} contains all the parts of implementation which refer to the splitting criteria. There are several packages inside. We explain some of them below:
\begin{description}
  \item[general] Here we have general classes which helps us to access the spit criterions and pruning methods in a common way.
  \item[iterators] This package contains classes to iterate over the instances in different ways, while calculating the splitting scores.
  \item[models] This package contains an implementation of the four split criteria proposed in \cite{dror2011thesis} and \cite{dror2014occt}.
  \item[pruning] Here we placed all the implementation of the two proposed pruning methods.
\end{description}
The {\em tree} package contains the implementation of the tree structure for representing internal nodes and leafs of the tree which are built during the training phase and queried during the testing phase. Finally, the {\em utils} package contains some general auxiliary classes which are used in the implementation.

\subsection{How It Works?}
Like in J48, the main class is called by the name of the algorithm - OCCT. The training is done via the {\em buildClassifier(Instances)} method which creates the root of the tree of the type {\em OCCTInternalClassifierNode} and calls its local {\em buildClassifier(Instances)} method.

\subsubsection{General}
The algorithm tries to recursively split the dataset contained in each node into subsets. Each internal node, represented by an instance of te {\em OCCTInternalClassifierNode} class, uses an attribute selection method (represented by the {\em OCCTSplitModelSelection} class), which tries to choose the best attribute for split. For this purpose, it evaluates the 'score' for each split (each attribute from $T_A$ defines a split) using an instance of {\em OCCTSingleAttributeSplitModel}.

\subsubsection{Splitting}
The split model can be of instance of one of the four proposed split criteria, e.g. represented by the {\em OCCTMaximumLikelihoodEstimationSplitModel class}. The base class for all the split criteria is {\em OCCTSingleAttributeSplitModel}. This class contains methods for performing basic operations like calculating intersection and union between sets of instances which is required for some of the split criterions. \vitali{TO BE CONTINUED}.

\subsubsection{Leafs}
Each leaf of the tree is represented by the {\em OCCTLeafNodeClass} class and contains the built probabilistic models (which are represented by the {\em ProbModelsHandler} class). Also, as mentioned in \cite{dror2011thesis} and \cite{dror2014occt}, there is no need to save models for all possible attributes of $T_B$. Thus, a feature selection process is executed on the leaf dataset in order to choose the attributes that will be represented by the leafs. This is done by the {\em OCCTFeatureSelector} class which is instantiated for each internal node and extracts the attributes of leafs in case this node has leafs as children.



\clearpage
\subsection{Main structure}
\begin{figure}[!h]
    \centering
\includegraphics[width=1\textwidth]{Figures/MainStructure}
    \caption{Main OCCT structure}
    \label{fig:mainstr}
\end{figure}








\section{Future Work and Extensions}
\begin{comment}
The major drawback of OCCT which has not been overcame in the implementation is too many possible configurations (four splitting criteria and two pruning methods). Thus, a characterization is required in order to decide which splitting criteria and pruning method should be used in each type of domain.
\end{comment}

There is still a lot of work that can be done in order to improve and extend the current implementation and allow it to be ran on more datasets. 

First, as noted in \cite{dror2011thesis}, the proposed OCCT algorithm is only capable of handling discrete data. Thus, it cannot analyze attributes that consist of continuous values. In case either $T_A$ or $T_B$ has such attributes, some kind of discretization must be applied in order to make them semi-nominal. This discretization must be done during a preprocess step, before running OCCT. In the current version of the implementation, Weka disables the possibility to ran the algorithm on datasets if they have at least one attribute that is not nominal. This is implemented by using the {\em Capabilities} class of Weka, which ensures that features (e.g. handling certain types of attributes) are enabled explicitly. Our suggestion is to implement this missing functionality and allow OCCT to handle both continuous and discrete attributes. For example, handling continuous attributes can be implemented in the same way of C4.5, which creates a threshold and then splits the instances into those whose attribute value is above the threshold and those that are less than or equal to it.

Other problem with the current implementation refers to the input format of the algorithm; currently, OCCT is referred as a classification algorithm, which means that it is located in the Classify tab of Weka and uses the common GUI of a classifier. However, OCCT purpose is solving data linkage problems. The uniqueness of these problems is receiving two datasets as an input and also irrelevant class attribute of the dataset. This type of input does not exist in the Classify tab of the GUI chooser of Weka. Currently, in order to overcome that problem of receiving two datasets as an input, we added an input index, which defines the first column of $T_B$ in the input. Since the input of the algorithm is a training set of only matching instances $T_AB \subseteq T_A \times T_B$, it is sufficient for now. However, Weka has an option of adding extra tabs in the Explorer in order to add new functionality without the hassle of having to dig into the code of the Explorer. We suggest to add a new tab for data linkage algorithms. This tab should be similar to the Classify tab, but it will allow the user to choose two different datasets for $T_A$ and $T_B$.

%----------------------------------------------------------------------------------------
\bibliographystyle{unsrt}
\bibliography{refFile}
\restoregeometry
\end{spacing}

\end{document}
